#!perl# Builds a distribution from the dist# Written for Classilla 9.0 (C)2009 Cameron Kaiser# Updated for Classilla 9.0.4 to support Application Bundles# GPLrequire 5.004;# in the future we may use more of these, I've included them all for# posterityuse Mac::Files;use Mac::Types;#use Mac::Events;#use Mac::AppleEvents;#use Mac::AppleEvents::Simple;#use Mac::Processes;use Mac::MoreFiles;use Mac::StandardFile;use File::Path;use File::Copy;use File::Basename;use Mac::Resources; # we need this to build the relative alias at the endprint "\n-- Classilla distribution generator --\n";#ActivateApplication('McPL');MacPerl::Answer("Select the executable in the dist:viewer folder. WARNING: Generated bundle will not be compatible with Mac OS X.", "OK");$classilla = StandardGetFile(0, "APPL");if ($classilla->sfGood()) {	$clap = dirname($classilla->sfFile());#	MacPerl::Answer("Awesome: $clap", "OK");} else {	MacPerl::Answer("Aborted.", "OK");	exit;}# Make the application home folder. This is what's dropped on MakeSMI, etc.$jclap = "${clap}:: RTM Package";mkdir($jclap, 0700) || do {	MacPerl::Answer("Unable to make $jclap: $! $@ $^E", "Abort");	exit;};$eclap = "${clap}::::Classilla Dist Resources";$hclap = $jclap;# Copy in the README first. This makes it appear in the right place later.# This is stored in ::::Classilla Dist Resources:.$eeclap = "${eclap}: READ ME FIRST";$hhclap = "${jclap}: READ ME FIRST";print "\nCopying Readme $eeclap -> $hhclap\n";copy($eeclap, $hhclap) || die("Copy failed: $! $@ $^E\n");# Copy in the pre-fab bundle folder. This is also stored in :::Classilla Dist Resources:# and has the skeleton stuff and aliases for the constant, unchanging content.$bclap = "${eclap}:Classilla.app";print "Creating skeleton bundle $bclap -> $jclap\n";FSpDirectoryCopy($bclap, $jclap, 0) || do {	MacPerl::Answer("FSpDirectory Copy failed: $! $@ $^E", "Abort");	exit;};# Remember this to make the clean up stuff at the end.$kclap = "${jclap}:Classilla.app";print "Successfully built skeleton bundle $kclap\n";# Copy will be done to the Contents folder within the pre-fab bundle skeleton.$jclap = "${kclap}:Contents";#mkdir($jclap, 0700) || do {#	MacPerl::Answer("Unable to make $jclap: $! $@ $^E", "Abort");#	exit;#};# Copy everything, turning aliases into real files, using breadth-first scanning.# There is a much simpler and probably more efficient way to do this, but# this manner ensures that everything is accounted for (and nothing you don't).(@dirs) = ( $clap );(@sources) = ();(@destinations) = ();while($dir = shift(@dirs)) {	opendir(D, $dir) || die("Failed to access $clap: $! $@ $^E\n");	ROAD: while($p = readdir(D)) {		$p = "$dir:$p";		print "$p";		if (-d $p) {			if ($p =~ /:CVS$/) {				print "<< skipping CVS directory\n";				next ROAD;			}			push(@dirs, $p);			print " << DIRECTORY\n";			$q = $p;			$q =~ s/^$clap/$jclap/;			print "making directory $q\n";			mkdir($q, 0700) || die("Failed to create $q: $! $@ $^E\n");			next ROAD;		}		if (-l $p) {			print " << ALIAS\n";			$j = readlink($p);			print "target is $j\n";			push(@sources, $j);		} else {			if ($p =~ /\.(idb|xSYM)$/) {				print "<< skipping CW bologna\n";				next ROAD;			}			print "\n";			push(@sources, $p);		}		$q = $p;		$q =~ s/^$clap/$jclap/;		print "converted to $q\n";		push(@destinations, $q);				#last ROAD; # test only	}	closedir(D);}print "\n\nCopying files ...\n";foreach(@sources) {	$k = shift(@destinations);	print "$_ => $k\n";	copy($_, $k) || die("Copy failed: $! $@ $^E\n");}# Create an alias to the new Classilla app, but RELATIVE.# Moz::Moz::MakeAlias will NOT work for this.# The obvious:# symlink(":Contents:Classilla", $kclap) || die("Symlink failed: $! $@ $^E\n");# won't work either. We have to do this the hard way. Partially based on:# http://developer.apple.com/legacy/mac/library/technotes/tn/tn1188.html# jclap is still our Contents folder, so $jclap:Classilla is our app# kclap is still our new package, so $kclap:Classilla alias is what we want to makeprint "\nBuilding application alias ...\n";# First, build a bogus alias. This is to get the Finder flags set for free.# (and the ApplicationAliasType, etc. It's a miracle of science and fraudulence.)# We're going to change this right away to our new relative alias.symlink("${kclap}:Contents:Classilla", "${kclap}:Classilla alias") 	|| die("Symlink failed: $! $@ $^E\n");$fsr = MacPerl::MakeFSSpec("${jclap}");$fsl = MacPerl::MakeFSSpec("${jclap}:Classilla");$alias_ref = NewAliasRelative($fsr, $fsl);if (!defined($alias_ref)) {	die("NewAliasRelative failure: $! $@ $^E\n");}# Replace the alias resource with our new one.$rfd = OpenResFile("${kclap}:Classilla alias") || die("OpenResFile failure: $! $@ $^E\n");$kAliasType = 'alis'; # I'm a lazy sod sosumi$rhandle = Get1Resource('alis', 0); # this should be thereif (defined($rhandle)) {	RemoveResource($rhandle);} else {	print "Warning: could not found alis 0 in the created alias\n"; # hmmmmm}AddResource($alias_ref, $kAliasType, 0, "PACKAGES SUCK KTHXBAI"); # yeah, yeah, hard coded, sosumi.CloseResFile($rfd);$alias_ref = undef; # release thisprint "-- completed (OSErr = $^E) --\n";