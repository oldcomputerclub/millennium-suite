#!perl# Classilla make clean, to prepare the tree for uploading source.# It needs improvement. It sort of works.# Written for Classilla (C)2009 Cameron Kaiser# GPLrequire 5.004;# in the future we may use more of these, I've included them all for# posterityuse Mac::Files;use Mac::Types;#use Mac::Events;#use Mac::AppleEvents;#use Mac::AppleEvents::Simple;#use Mac::Processes;use Mac::MoreFiles;use Mac::StandardFile;use File::Path;use File::Copy;use File::Basename;# master switch.$ACTUALLY_DELETE = 1;print "\n-- Classilla make clean --\n";MacPerl::Answer("Locate the mozilla folder by picking any file in it.", "OK");$classilla = StandardGetFile(0, "");if ($classilla->sfGood()) {	$clap = dirname($classilla->sfFile());#	MacPerl::Answer("Awesome: $clap", "OK");} else {	MacPerl::Answer("Aborted.", "OK");	exit;}# There is a much simpler and probably more efficient way to do this, but# this manner ensures that everything is accounted for (and nothing you don't).(@dirs) = ( $clap );(@dirstodie) = ();while($dir = shift(@dirs)) {	opendir(D, $dir) || die("Failed to access $clap: $!");	# Deletions need to be done *after* the directory is read	# or we get inexplicable errors.	(@filestodie) = ();	ROAD: while($p = readdir(D)) {		$pp = $p;		$p = "$dir:$p";		(@splath) = split(/:/, $p);				# add folders to destroy to @dirstodie		if (-d $p) {			if (grep(($_ eq 'CVS'), @splath) ||				grep(/^_[^\s]+ Data$/, @splath) ||					0) {				print "* Folder scheduled for deletion: $p\n";				push(@dirstodie, $p);			}			push(@dirs, $p);			next ROAD;		}				# find files to destroy		if(grep(($_ eq 'CVS'), @splath) ||			grep(/^_[^\s]+ Data$/, @splath) ||			$pp =~ /^\.\#/ ||			# cvsignore? maybe later if we completely remove all traces.			$p =~ /\.shlb$/ ||			$p =~ /\.o$/ ||			$p =~ /\.xSYM$/ ||			$p =~ /\.xpt$/ ||			$p =~ /\.idb$/ ||			# not sure if .jars should be in this list. probably, need to investigate more.			# NO. This will destroy our locales. we'll live with .jars.				0) {			push(@filestodie, $p);		}	}	closedir(D);	$p = ''; # safety first	foreach(@filestodie) {		print "Deleting: $_\n";		if ($ACTUALLY_DELETE) {			die("failed to delete: $!\n") if (!unlink($_));		}	}}print "\n-- cleaning up orphan folders --\n";while($p = pop(@dirstodie)) {	next if (! -e $p);	print "Deleting: $p\n";	if ($ACTUALLY_DELETE) {		die("failed to rmdir: $!\n") if (!rmdir($p));	}}print "\n--- spotless ---\n";