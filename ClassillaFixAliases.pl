#!perl# Classilla fix aliases. This pisses me off to no end how they get munged,# and MakeAlias does not seem to reliably fix them. This reliably fixes them.# It also needs a lot of memory, but if you're building Mozilla, you probably# gave plenty to MacPerl already.# Written for Classilla (C)2009 Cameron Kaiser# GPLrequire 5.004;# in the future we may use more of these, I've included them all for# posterityuse Mac::Files;use Mac::Types;#use Mac::Events;#use Mac::AppleEvents;#use Mac::AppleEvents::Simple;#use Mac::Processes;use Mac::MoreFiles;use Mac::StandardFile;use File::Path;use File::Copy;use File::Basename;print "\n-- Classilla alias fixer --\n";MacPerl::Answer("Locate the mozilla folder by picking any file in it.", "OK");$classilla = StandardGetFile(0, "");if ($classilla->sfGood()) {	$clap = dirname($classilla->sfFile());#	MacPerl::Answer("Awesome: $clap", "OK");} else {	MacPerl::Answer("Aborted.", "OK");	exit;}# There is a much simpler and probably more efficient way to do this, but# this manner ensures that everything is accounted for (and nothing you don't).(@dirs) = ( $clap );%needtofix = ();%filedatabase = ();while($dir = shift(@dirs)) {	opendir(D, $dir) || die("Failed to access $clap: $!");	ROAD: while($p = readdir(D)) {		$pp = $p;		$p = "$dir:$p";		if (-d $p) {			if ($p =~ /:CVS$/) {				print "$p << skipping CVS directory\n";				next ROAD;			}			push(@dirs, $p);			print "$p << DIRECTORY\n";			next ROAD;		}		if (-l $p) {			print "$p << ALIAS ";			$j = readlink($p);			#print "\ntarget is $j ...";			if (-e $j && -r $j) {				print "target is GOOD.\n"			} else {				print "target is BAD!!\n";				$needtofix{$p} = $j;			}		} else {			if ($filedatabase{$pp}) {				#print "Warning: collision with key $pp in $p, this might be a problem\n";				$filedatabase{$pp} = "COLLISION";			} else {				#print "$pp => $p\n";				$filedatabase{$pp} = $p;			}		}	}	closedir(D);}print "\n";print scalar(keys(%needtofix)), " fixes needed.\n";(@failedtofix) = ();(@failedtoresolve) = ();foreach (keys %needtofix) {	print "$_ => $needtofix{$_} ";	$j = $filedatabase{basename($_)};	if ($j eq 'COLLISION') {		print "Multiple files match! Not touching!\n";		push(@failedtofix, $_);	} elsif ($j) {		unlink($_);		symlink($j, $_);		print "repaired to $j\n";	} else {		print "No match! Not touching!\n";		push(@failedtoresolve, $_);	}}print "\n-- completed --\n";foreach (@failedtofix) {	print "Still need to resolve: $_\n";}foreach (@failedtoresolve) {	print "Couldn't find anything to match: $_\n";}